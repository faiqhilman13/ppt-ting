from app.providers.base import BaseLLMProvider, SlideContent


class MockProvider(BaseLLMProvider):
    name = "mock"

    @staticmethod
    def _slot_value(slot: str, prompt: str, slide_number: int, sources: list[str], extra_instructions: str | None = None) -> str:
        s = slot.upper()

        if "TITLE" in s:
            return f"{prompt[:90]} - Slide {slide_number}"
        if "SUBTITLE" in s:
            return "AI-generated draft aligned to template style"
        if "BULLET" in s:
            return "Key point one\nKey point two\nKey point three"
        if "SOURCE" in s or "CITATION" in s or "REFERENCE" in s:
            return "; ".join(sources[:3]) if sources else "Internal + web research"
        if "FOOTER" in s:
            return "Generated by PowerPoint Agent"
        if "TABLE" in s:
            return "Data available in supporting notes"

        body = (
            f"This section summarizes the topic '{prompt}'. "
            f"It is populated from uploaded docs and web research evidence."
        )
        if extra_instructions:
            body += f" Additional instruction: {extra_instructions}."
        return body

    def generate_slides(self, prompt, research_chunks, template_manifest, slide_count, extra_instructions=None, deck_thesis=None):
        self.reset_warnings()
        template_slides = template_manifest.get("slides") or []
        if not template_slides:
            return []

        target_count = min(slide_count, len(template_slides))
        sources = [chunk.get("title", "Source") for chunk in research_chunks][:5]

        result: list[SlideContent] = []
        for idx in range(target_count):
            spec = template_slides[idx]
            scoped_prompt = prompt
            if deck_thesis:
                scoped_prompt = f"{prompt}. Thesis: {deck_thesis}"
            slots = {
                slot_name: self._slot_value(slot_name, scoped_prompt, idx + 1, sources, extra_instructions)
                for slot_name in spec.get("slots", [])
            }
            result.append(SlideContent(template_slide_index=spec.get("index", idx), slots=slots))

        return result

    def revise_slides(self, prompt, existing_slides, research_chunks, template_manifest):
        self.reset_warnings()
        revised: list[SlideContent] = []
        for idx, slide in enumerate(existing_slides, start=1):
            current_slots = slide.get("slots", {})
            updated: dict[str, str] = {}

            for slot_name, old_value in current_slots.items():
                if "TITLE" in slot_name.upper():
                    updated[slot_name] = f"{old_value} (Revised)"
                else:
                    updated[slot_name] = f"{old_value}\n\nRevision request: {prompt}".strip()

            revised.append(
                SlideContent(
                    template_slide_index=slide.get("template_slide_index", idx - 1),
                    slots=updated,
                )
            )

        return revised

    def generate_text(self, *, system_prompt: str, user_prompt: str, max_tokens: int = 180) -> str:
        text = user_prompt.strip().rstrip(".")
        if not text:
            return "This deck presents a clear, decision-oriented recommendation."
        return f"This deck argues that {text}. It supports this with evidence, tradeoffs, and a concrete execution path."

    def generate_outline(self, *, prompt: str, template_manifest: dict, slide_count: int, research_chunks: list[dict]) -> dict:
        self.reset_warnings()
        slides = (template_manifest.get("slides") or [])[:slide_count]
        thesis = self.generate_text(system_prompt="Generate a deck thesis", user_prompt=prompt, max_tokens=120)
        outline_rows = []
        for idx, row in enumerate(slides, start=1):
            outline_rows.append(
                {
                    "template_slide_index": int(row.get("index", idx - 1)),
                    "narrative_role": f"Step {idx}: {row.get('archetype', 'general')} narrative progression.",
                    "key_message": f"Key point for step {idx} that supports the thesis.",
                }
            )
        return {"thesis": thesis, "slides": outline_rows}
