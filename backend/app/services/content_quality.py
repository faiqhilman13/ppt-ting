from __future__ import annotations

import re
from typing import Any

from app.services.slide_archetypes import classify_slot, slot_budget

TOKEN_PATTERN = re.compile(r"\{\{\s*[A-Za-z0-9_:-]+\s*\}\}")
MULTISPACE_PATTERN = re.compile(r"\s+")
BULLET_PREFIX_PATTERN = re.compile(r"^\s*[-*\u2022]\s+")
INLINE_BULLET_SPLIT_PATTERN = re.compile(r"\s*\u2022+\s*")


def _clean_text(text: str, *, keep_newlines: bool = False) -> str:
    text = TOKEN_PATTERN.sub("", text or "")
    text = text.replace("\u00a0", " ")
    if keep_newlines:
        text = text.replace("\r\n", "\n").replace("\r", "\n")
        lines = [MULTISPACE_PATTERN.sub(" ", row).strip() for row in text.split("\n")]
        return "\n".join([row for row in lines if row])
    return MULTISPACE_PATTERN.sub(" ", text).strip()


def _trim_to_budget(text: str, budget: int) -> str:
    if len(text) <= budget:
        return text

    cut = text[:budget].rstrip()
    # Prefer sentence-safe trim.
    stop = max(cut.rfind("."), cut.rfind(";"), cut.rfind(":"))
    if stop >= int(budget * 0.6):
        cut = cut[: stop + 1].strip()
    return cut


def _format_bullets(text: str, max_items: int = 5) -> str:
    normalized = (
        (text or "")
        .replace("â€¢", "\u2022")
        .replace("\r\n", "\n")
        .replace("\r", "\n")
    )

    parts: list[str] = []
    for row in normalized.split("\n"):
        line = row.strip()
        if not line:
            continue

        # Handle inline bullet separators like: "• one • two • three"
        if "\u2022" in line:
            inline_parts = [chunk.strip(" ;") for chunk in INLINE_BULLET_SPLIT_PATTERN.split(line) if chunk.strip()]
            if len(inline_parts) > 1:
                parts.extend(inline_parts)
                continue

        # Only strip "-" when it is a bullet marker at start of line.
        cleaned = BULLET_PREFIX_PATTERN.sub("", line).strip(" ;")
        if cleaned:
            parts.append(cleaned)

    if not parts:
        return "Key point 1\nKey point 2\nKey point 3"
    return "\n".join(parts[:max_items])


def _default_for_slot(slot: str, prompt: str, source_titles: list[str]) -> str:
    slot_type = classify_slot(slot)
    if slot_type == "TITLE":
        return prompt[:90]
    if slot_type == "SUBTITLE":
        return "Draft generated by AI"
    if slot_type == "BULLET":
        return "Key point 1\nKey point 2\nKey point 3"
    if slot_type == "CITATION":
        if source_titles:
            return "Source: " + "; ".join(source_titles[:2])
        return "Source: Uploaded and web research"
    if slot_type == "FOOTER":
        return "Prepared by PowerPoint Agent"
    return f"Summary: {prompt[:160]}"


def _slot_context_for_slide(spec: dict[str, Any]) -> dict[str, dict[str, Any]]:
    context: dict[str, dict[str, Any]] = {}
    for binding in spec.get("bindings", []) or []:
        slot_name = str(binding.get("slot", "")).strip()
        if not slot_name or slot_name in context:
            continue
        context[slot_name] = {
            "width_inches": binding.get("width_inches"),
            "height_inches": binding.get("height_inches"),
            "font_size_pt": binding.get("font_size_pt"),
        }
    return context


def _check_keyword_alignment(title: str, body: str, threshold: float = 0.5) -> bool:
    stopwords = {"the", "a", "an", "is", "are", "and", "or", "of", "to", "in", "for", "with", "on"}
    title_words = {word for word in re.findall(r"[A-Za-z0-9]+", (title or "").lower()) if word not in stopwords}
    if not title_words:
        return True
    body_lower = (body or "").lower()
    matches = sum(1 for word in title_words if word in body_lower)
    return (matches / len(title_words)) >= threshold


def validate_and_rewrite_slides(
    *,
    slides_payload: list[dict],
    template_manifest: dict,
    prompt: str,
    research_chunks: list[dict],
) -> tuple[list[dict], dict[str, Any]]:
    manifest_by_index = {int(row.get("index", i)): row for i, row in enumerate(template_manifest.get("slides", []))}
    source_titles = [chunk.get("title", "") for chunk in research_chunks if chunk.get("title")]

    rewrites = 0
    warnings: list[str] = []

    normalized: list[dict] = []
    for slide in slides_payload:
        idx = int(slide.get("template_slide_index", -1))
        spec = manifest_by_index.get(idx)
        if not spec:
            warnings.append(f"Unknown template_slide_index={idx}; skipped")
            continue

        archetype = spec.get("archetype", "general")
        expected_slots = list(spec.get("slots", []))
        slot_context = _slot_context_for_slide(spec)
        current_slots = {str(k): str(v) for k, v in (slide.get("slots") or {}).items()}

        final_slots: dict[str, str] = {}
        for slot in expected_slots:
            slot_type = classify_slot(slot)
            value = _clean_text(current_slots.get(slot, ""), keep_newlines=slot_type == "BULLET")

            if not value:
                value = _default_for_slot(slot, prompt, source_titles)
                rewrites += 1
                warnings.append(f"Filled missing slot {slot} on slide {idx}")

            if slot_type == "BULLET":
                formatted = _format_bullets(value)
                if formatted != value:
                    rewrites += 1
                value = formatted

            budget = slot_budget(archetype, slot, slot_context.get(slot))
            trimmed = _trim_to_budget(value, budget)
            if trimmed != value:
                rewrites += 1
                warnings.append(f"Trimmed slot {slot} on slide {idx} to budget {budget}")
            value = trimmed

            if slot_type == "CITATION" and "source:" not in value.lower():
                value = "Source: " + value
                rewrites += 1

            final_slots[slot] = value

        normalized.append(
            {
                "template_slide_index": idx,
                "archetype": archetype,
                "slots": final_slots,
            }
        )

        title_text = " ".join(
            value
            for slot_name, value in final_slots.items()
            if classify_slot(slot_name) in {"TITLE", "SUBTITLE"}
        )
        body_text = " ".join(
            value
            for slot_name, value in final_slots.items()
            if classify_slot(slot_name) in {"BODY", "BULLET", "TABLE"}
        )
        if title_text and body_text and not _check_keyword_alignment(title_text, body_text):
            warnings.append(f"Low title/body keyword alignment on slide {idx}")

    report = {
        "rewrites_applied": rewrites,
        "warnings": warnings,
        "slide_count": len(normalized),
    }

    return normalized, report
