from __future__ import annotations

import re
from typing import Any

from app.services.slide_archetypes import classify_slot, slot_budget

TOKEN_PATTERN = re.compile(r"\{\{\s*[A-Za-z0-9_:-]+\s*\}\}")
MULTISPACE_PATTERN = re.compile(r"\s+")


def _clean_text(text: str) -> str:
    text = TOKEN_PATTERN.sub("", text or "")
    text = text.replace("\u00a0", " ")
    text = MULTISPACE_PATTERN.sub(" ", text).strip()
    return text


def _trim_to_budget(text: str, budget: int) -> str:
    if len(text) <= budget:
        return text

    cut = text[:budget].rstrip()
    # Prefer sentence-safe trim.
    stop = max(cut.rfind("."), cut.rfind(";"), cut.rfind(":"))
    if stop >= int(budget * 0.6):
        cut = cut[: stop + 1].strip()
    return cut


def _format_bullets(text: str, max_items: int = 5) -> str:
    raw = text.replace("•", "\n").replace("-", "\n")
    parts = [p.strip(" ;") for p in raw.split("\n") if p.strip()]
    if not parts:
        return "• Key point 1\n• Key point 2\n• Key point 3"
    parts = parts[:max_items]
    return "\n".join(f"• {p}" for p in parts)


def _default_for_slot(slot: str, prompt: str, source_titles: list[str]) -> str:
    slot_type = classify_slot(slot)
    if slot_type == "TITLE":
        return prompt[:90]
    if slot_type == "SUBTITLE":
        return "Draft generated by AI"
    if slot_type == "BULLET":
        return "• Key point 1\n• Key point 2\n• Key point 3"
    if slot_type == "CITATION":
        if source_titles:
            return "Source: " + "; ".join(source_titles[:2])
        return "Source: Uploaded and web research"
    if slot_type == "FOOTER":
        return "Prepared by PowerPoint Agent"
    return f"Summary: {prompt[:160]}"


def validate_and_rewrite_slides(
    *,
    slides_payload: list[dict],
    template_manifest: dict,
    prompt: str,
    research_chunks: list[dict],
) -> tuple[list[dict], dict[str, Any]]:
    manifest_by_index = {int(row.get("index", i)): row for i, row in enumerate(template_manifest.get("slides", []))}
    source_titles = [chunk.get("title", "") for chunk in research_chunks if chunk.get("title")]

    rewrites = 0
    warnings: list[str] = []

    normalized: list[dict] = []
    for slide in slides_payload:
        idx = int(slide.get("template_slide_index", -1))
        spec = manifest_by_index.get(idx)
        if not spec:
            warnings.append(f"Unknown template_slide_index={idx}; skipped")
            continue

        archetype = spec.get("archetype", "general")
        expected_slots = list(spec.get("slots", []))
        current_slots = {str(k): str(v) for k, v in (slide.get("slots") or {}).items()}

        final_slots: dict[str, str] = {}
        for slot in expected_slots:
            value = _clean_text(current_slots.get(slot, ""))

            if not value:
                value = _default_for_slot(slot, prompt, source_titles)
                rewrites += 1
                warnings.append(f"Filled missing slot {slot} on slide {idx}")

            slot_type = classify_slot(slot)
            if slot_type == "BULLET":
                formatted = _format_bullets(value)
                if formatted != value:
                    rewrites += 1
                value = formatted

            budget = slot_budget(archetype, slot)
            trimmed = _trim_to_budget(value, budget)
            if trimmed != value:
                rewrites += 1
                warnings.append(f"Trimmed slot {slot} on slide {idx} to budget {budget}")
            value = trimmed

            if slot_type == "CITATION" and "source:" not in value.lower():
                value = "Source: " + value
                rewrites += 1

            final_slots[slot] = value

        normalized.append(
            {
                "template_slide_index": idx,
                "archetype": archetype,
                "slots": final_slots,
            }
        )

    report = {
        "rewrites_applied": rewrites,
        "warnings": warnings,
        "slide_count": len(normalized),
    }

    return normalized, report
